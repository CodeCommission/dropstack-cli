#!/usr/bin/env node
const DROPSTACK_BASE_URL = process.env.DROPSTACK_BASE_URL || `https://api.dropstack.run`;

const fs = require('fs');
const path = require('path');
const os = require('os');
const program = require('commander');
const chalk = require('chalk');
const tar = require('tar');
const fstream = require('fstream');
const fetch = require('node-fetch');
const copyPaste = require('copy-paste');
const ProgressBar = require('progress');
const FormData = require('form-data');
const credentials = require('../lib/credentials')();
const stackSettings = require('../lib/settings')();
process.on('SIGINT', () => process.exit(0));

program
  .arguments('[folder]')
  .option('-l, --login', 'Force login')
  .option('-r, --reset', 'Reset login')
  .option('-v, --variables <items>', 'Key=Value variables', (item, list) => { list.push(item); return list; }, [])
  .option('-i, --instances <number>', 'Number of running instances')
  .option('-c, --cname <string>', 'Set a canonical name (CNAME) (e.g. my.dropstack.run)')
  .parse(process.argv);

if(!program.args.length) deploy(Object.assign(program.opts(), {folder: process.cwd()}));

function deploy({folder, login, reset, variables, instances, cname, excludes}){
  const args = path.resolve(folder);
  const pathObj = path.parse(args);
  const tarPath = path.join(os.tmpdir(), `${pathObj.name}.tar`);
  const dirDest = fs.createWriteStream(tarPath);
  const packer = tar.Pack({ noProprietary: true, fromBase: true })
    .on('error', err => console.error(chalk.red(`An error occurred: ${chalk.gray(err.message)}`)))
    .on('end', () => sync({
      tarPath,
      variables,
      reset,
      login,
      instances,
      cname,
    }));

  fstream.Reader({ path: args, type: 'Directory', follow: false, filter: x => tarFileFilter(x, excludes)})
    .on('error', err => console.error(chalk.red(`An error occurred: ${chalk.gray(err.message)}`)))
    .pipe(packer)
    .pipe(dirDest);
}

function sync({tarPath, login, reset, variables, instances, cname}){
  stackSettings.load({variables, tarPath, instances, cname})
  .then(settings => credentials.inputEmail(login ? '' : settings.username).then(data => Object.assign(settings, data)))
  .then(settings => reset ? credentials.reset(settings).then(data => Promise.reject(data)) : Promise.resolve(settings))
  .then(settings => login ? credentials.inputPassword(settings.password).then(data => Object.assign(settings, data)) : Promise.resolve(settings))
  .then(settings => !settings.token ? credentials.login(settings).catch(() => credentials.signup(settings)).then(data => Object.assign(settings, data)) : Promise.resolve(settings))
  .then(settings => {
    if(settings.message) return Promise.reject(new Error(settings.message));
    return settings;
  })
  .then(settings => stackSettings.save(settings))
  .then(settings => deployment(settings))
  .then(settings => stackSettings.save(settings))
  .then(settings => {
    console.log(chalk.green('Deployment completed'), chalk.gray('Instance URL copied to clipboard.'));
    console.log(`Stack-URL: ${chalk.bold(settings.serviceUrl)}`);
    if(settings && settings.serviceCName && settings.serviceCName.replace('https://', '')) console.log(`Stack-CName: ${settings.serviceCName}`);
  })
  .catch(err => {
    if(err.message === '"We\'ve just sent you an email to reset your password."') {
      console.log(chalk.red(err.message));
      return process.exit(0);
    }
    if(err.message === 'canceled') {
      console.log(chalk.yellow('aborted'));
      return process.exit(0);
    }
    if(err.message === 'The user already exists.') {
      console.error(chalk.red(`Login failed`))
      return process.exit(1);
    }

    console.error(chalk.red(`\nAn error occurred ${chalk.gray(err.message)}`));
    process.exit(1);
  });
}

function deployment(settings) {
  const pathObj = path.parse(settings.tarPath);
  const form = new FormData();
  const bar = new ProgressBar('[:current/:total :deployProgress] [:bar] :percent :elapseds', { total: 11, width: 24 });

  settings
    .variables
    .forEach(x => {
      const item = x.split('=');
      if(!item[0]) return;

      form.append(item[0], item[1]);
    });

  if(settings.serviceName) form.append('serviceName', settings.serviceName);
  if(settings.cname) form.append('serviceCname', settings.cname);
  if(settings.instances) form.append('serviceInstances', settings.instances);
  form.append(pathObj.name, fs.createReadStream(settings.tarPath));

  return fetch(`${DROPSTACK_BASE_URL}/stacks/${pathObj.name}`, {
    method: 'POST',
    body: form,
    headers: { Authorization: `Bearer ${settings.token}`, }
  })
  .then(response => {
    return new Promise((resolve, reject) => {
      let result = undefined;
      response.body.on('end', () => resolve(result));
      response.body.on('data', data => {
        try{
          const progressState = JSON.parse(data);
          result = progressState;
          if(progressState && progressState.message) return Promise.reject(new Error(progressState.message));
          if(progressState && progressState.deployProgress) bar.tick(progressState);
        } catch(err) {
          reject(err);
        }
      });

    });
  })
  .then(data => {
    settings.serviceName = data.serviceName;
    settings.serviceUrl = data.serviceUrl;
    settings.serviceCName = data.serviceCName;
    copyPaste.copy(data.serviceUrl);
    return settings;
  });
}

function tarFileFilter(entry, excludes = []) {
  return entry.basename !== 'node_modules' && entry.basename !== 'npm-debug.log' && entry.basename !== '.git';
}
