#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const os = require('os');
const program = require('commander');
const chalk = require('chalk');
const tar = require('tar');
const fstream = require('fstream');
const fetch = require('node-fetch');
const copyPaste = require('copy-paste');
const ProgressBar = require('progress');
const FormData = require('form-data');
const credentials = require('../lib/credentials')();
const configuration = require('../lib/settings')();

program
  .arguments('[folder]')
  .option('-l, --login', 'Force login')
  .option('-r, --reset', 'Reset login')
  .option('-a, --alias [name]', 'Set alias of deployment', '')
  .option('-v, --variables [items]', 'Key=Value variables', (item, list) => { list.push(item); return list; }, [])
  .option('-i, --instances [number]', 'Number of running instances for deployment')
  .parse(process.argv);

deploy(Object.assign(program.opts(), {folder: program.args.length === 0 ? process.cwd() : program.args[0] }));

function deploy({folder, login, reset, variables, instances, alias}){
  const args = path.resolve(folder);
  const pathObj = path.parse(args);
  const tarPath = path.join(os.tmpdir(), `${pathObj.name}.tar`);
  const dirDest = fs.createWriteStream(tarPath);
  const packer = tar
    .Pack({ noProprietary: true, fromBase: true })
    .on('error', err => console.error(chalk.red(`An error occurred: ${chalk.gray(err.message)}`)))
    .on('end', () => sync({
      tarPath,
      variables,
      reset,
      login,
      instances,
      alias,
    }));

  configuration
  .load()
  .then(settings => {
    fstream.Reader({ path: args, type: 'Directory', follow: false, filter: x => tarFileFilter(x, settings.excludes)})
      .on('error', err => console.error(chalk.red(`An error occurred: ${chalk.gray(err.message)}`)))
      .pipe(packer)
      .pipe(dirDest);
  });
}

function sync({tarPath, login, reset, variables, instances, alias}){
  configuration
  .load({variables, tarPath, instances, alias})
  .then(settings => { console.log(`Deploy for ${chalk.green.underline(settings.alias || settings.name || '-')} | ${chalk.green.underline(settings.username || '-')} | ${chalk.green.underline(settings.url || '-')}`); return settings;})
  .then(settings => credentials.inputEmail(login ? '' : settings.username).then(data => Object.assign(settings, data)))
  .then(settings => reset ? credentials.reset(settings).then(data => Promise.reject(data)) : Promise.resolve(settings))
  .then(settings => login ? credentials.inputPassword(settings.password).then(data => Object.assign(settings, data)) : Promise.resolve(settings))
  .then(settings => !settings.token ? credentials.login(settings).catch(() => credentials.signup(settings)).then(data => Object.assign(settings, data)) : Promise.resolve(settings))
  .then(settings => {
    if(settings.message) return Promise.reject(new Error(settings.message));
    return settings;
  })
  .then(settings => configuration.save(settings))
  .then(settings => deployment(settings))
  .then(settings => configuration.save(settings))
  .then(settings => {
    console.log(chalk.green('\nDeployment completed'), chalk.gray('Instance URL copied to clipboard.'));
    console.log(`Deploy URL: ${chalk.bold(settings.serviceUrl)}`);
    if(settings && settings.serviceAlias) console.log(`Alias URL: ${settings.serviceAlias}`);
  })
  .catch(err => {
    if(err.message === '"We\'ve just sent you an email to reset your password."') {
      console.log(chalk.red(err.message));
      return process.exit(0);
    }
    if(err.message === 'canceled') {
      console.log(chalk.yellow('aborted'));
      return process.exit(0);
    }
    if(err.message === 'The user already exists.') {
      console.error(chalk.red(`Login failed`))
      return process.exit(1);
    }
    if(err.message.indexOf('building error') !== -1) {
      console.error(chalk.red(`\n${err.message}`))
      console.error(chalk.red(`Verify your Dockerfile, please!`))
      return process.exit(1);
    }
    console.error(chalk.red(`\nAn error occurred ${chalk.gray(err.message)}`));
    process.exit(1);
  });
}

function deployment(settings) {
  const pathObj = path.parse(settings.tarPath);
  const form = new FormData();
  const bar = new ProgressBar('[:current/:total :deployProgress] [:bar] :percent :elapseds', { total: 11, width: 24 });

  if(settings.name) form.append('serviceName', settings.name);
  if(settings.alias) form.append('serviceAlias', settings.alias);
  if(settings.instances) form.append('serviceInstances', settings.instances);
  if(settings.variables) form.append('serviceVariables', settings.variables.join(','));
  form.append(pathObj.name, fs.createReadStream(settings.tarPath));

  return fetch(`${settings.url}/deploys/${settings.name || ''}`, {
    method: 'POST',
    body: form,
    headers: { Authorization: `Bearer ${settings.token}`, }
  })
  .then(response => {
    return new Promise((resolve, reject) => {
      let result = undefined;
      response.body.on('end', () => resolve(result));
      response.body.on('data', data => {
        try {
          const progressState = JSON.parse(data);
          result = progressState;
          if(progressState && progressState.message) return reject(new Error(`${progressState.deployProgress}: ${progressState.message}`));
          if(progressState && progressState.deployProgress) bar.tick(progressState);
        } catch(err) {
          reject(err);
        }
      });
    });
  })
  .then(data => {
    settings.name = data.serviceName;
    settings.serviceUrl = data.serviceUrl;
    settings.alias = data.serviceAlias;
    settings.type = data.serviceType;
    settings.instances = data.serviceInstances;
    settings.variables = data.serviceVariables;
    copyPaste.copy(data.serviceUrl || '');
    return settings;
  });
}

function tarFileFilter(entry, excludes = []) {
  return excludes.every(x => x !== entry.basename) && entry.basename !== 'node_modules' && entry.basename !== 'npm-debug.log' && entry.basename !== '.git';
}
