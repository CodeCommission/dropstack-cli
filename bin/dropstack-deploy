#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const os = require('os');
const program = require('commander');
const boxen = require('boxen');
const chalk = require('chalk');
const tar = require('tar');
const minimatch = require('minimatch');
const fstream = require('fstream');
const fetch = require('node-fetch');
const copyPaste = require('copy-paste');
const FormData = require('form-data');
const EventSource = require('eventsource');
const credentials = require('../lib/credentials')();
const configurationSettings = require('../lib/settings');
let configuration;

program
  .arguments('[folder]')
  .option('-t, --token [token]', 'Use JSON Web Token credentials', '')
  .option('-a, --alias [name]', 'Set alias of deployment', '')
  .option('-u, --url [url]', 'Set server URL of deployment', '')
  .option('-e, --environment [name]', 'Set an environment name of deployment', '')
  .option('-y, --type [name]', 'Set type of deployment manually', '')
  .option('-s, --https', 'Enable HTTPS/HTTP2/SPDY of deployment', false)
  .option('-m, --alive-endpoint [path]', 'Alive monitoring endpoint (/info)', '')
  .option('-v, --variables [items]', 'Key=Value variables', (item, list) => { list.push(item); return list; }, [])
  .option('-x, --excludes [items]', 'Exclude files (globs)', (item, list) => { list.push(item); return list; }, [])
  .option('-i, --instances [number]', 'Number of running instances for deployment', 0)
  .option('-o, --verbose', 'Enable verbose deployment output')
  .parse(process.argv);

deploy(Object.assign(program.opts(), {folder: program.args.length === 0 ? process.cwd() : program.args[0] }));

function deploy({folder, token, variables, instances, alias, https, type, url, environment, aliveEndpoint, verbose, excludes}){
  configuration = configurationSettings(`.dropstack${environment ? '.' + environment + '.' : '.'}json`);

  const args = path.resolve(folder);
  const pathObj = path.parse(args);
  const tarPath = path.join(os.tmpdir(), `${pathObj.name}.tar`);
  const dirDest = fs.createWriteStream(tarPath);
  const packer = tar
    .Pack({ noProprietary: true, fromBase: true })
    .on('error', err => console.error(chalk.red(`\nAn unexpected error occurred!\nMessage: ${chalk.gray(err.message)}`)))
    .on('end', () => sync({
      tarPath,
      variables,
      token,
      instances,
      alias,
      type,
      https,
      aliveEndpoint,
      url,
      verbose,
      excludes,
    }));

  configuration
  .load()
  .then(settings => {
    fstream.Reader({ path: args, type: 'Directory', follow: false, filter: x => tarFileFilter(x, settings.excludes)})
      .on('error', err => console.error(chalk.red(`\nAn unexpected error occurred!\nMessage: ${chalk.gray(err.message)}`)))
      .pipe(packer)
      .pipe(dirDest);
  });
}

function sync({tarPath, token, variables, instances, alias, type, https, url, aliveEndpoint, verbose, excludes}){
  configuration
  .load({variables, tarPath, instances, token, alias, type, https, url, aliveEndpoint, excludes})
  .then(settings => Boolean(!(settings.token && settings.username)) ? Promise.reject(new Error('Sign in failed. Use `dropstack login` to log in with your credentials.')) : settings)
  .then(settings => { console.log(`Deploying ${chalk.green.underline(settings.alias || settings.name || '-')} for ${chalk.green.underline(settings.username || '-')} on ${chalk.green.underline(settings.url || '-')}`); return settings;})
  .then(settings => {
    if(settings.message) return Promise.reject(new Error(settings.message));
    return settings;
  })
  .then(settings => deployment(settings, verbose))
  .then(settings => configuration.save(settings))
  .then(settings => {
    let message = chalk.green(`Deployment ${chalk.bold(settings.name || '-')} completed - ${settings && settings.instances && `${settings.instances} running instance(s)!\n`}`);
    message += '\n';
    message += `• URL: ${chalk.bold(`https://${settings.serviceUrl}`)}\n`;
    if(settings && settings.alias) message += `• Alias: ${chalk.bold(settings.alias)}\n`;
    message += `\n${chalk.gray('URL copied to clipboard.')}`;
    console.log();
    console.log(boxen(message, {padding: 1, borderColor: 'gray', margin: 1}));
  })
  .catch(err => {
    if(err.message === 'canceled') {
      console.log(chalk.yellow('aborted'));
      return process.exit(0);
    }
    if(err.message.indexOf('building error') !== -1) {
      console.error(chalk.red(`\n${err.message}`))
      console.error(chalk.red(`Verify your Dockerfile, please!`))
      return process.exit(1);
    }
    if(err.message === 'Sign in failed. Use `dropstack login` to log in with your credentials.'){
      console.error(chalk.red(`Credentials not found. Use ${chalk.bold('dropstack login')} to verifiy your credentials.`));
      process.exit(1);
    }
    if(err.message.indexOf('Deployment error occurred') !== -1) {
      console.error(chalk.red(`\n${err.message}. Retry please!`))
      return process.exit(1);
    }

    console.error(chalk.red(`\nAn unexpected error occurred!\nMessage: ${chalk.gray(err.message)}`));
    process.exit(1);
  });
}

function deployment(settings, verbose) {
  const pathObj = path.parse(settings.tarPath);
  const form = new FormData();

  if(settings.name) form.append('serviceName', settings.name);
  if(settings.alias) form.append('serviceAlias', settings.alias);
  if(settings.https) form.append('serviceHTTPS', settings.https.toString());
  if(settings.type) form.append('serviceType', settings.type);
  if(settings.instances) form.append('serviceInstances', settings.instances);
  if(settings.aliveEndpoint) form.append('serviceAliveEndpoint', settings.aliveEndpoint);
  if(settings.variables) form.append('serviceVariables', settings.variables);
  form.append(pathObj.name, fs.createReadStream(settings.tarPath));

  return new Promise((resolve, reject) => {
    const spin = ' ⢹⢺⢼⣸⣇⡧⡗⡏'.split('');
    const startDate = new Date();
    let n = 1;
    const es = new EventSource(`${settings.url}/deploys/live`, {headers: {connection: 'keep-alive', 'cache-control': 'no-cache', authorization: `Bearer ${settings.token}`}});
    process.stderr.write('\x1B[?25l'); //hide terminal cursor

    es.onerror = () => {
      process.stderr.write('\x1B[?25h'); //show terminal cursor
      reject(new Error('Deployment error occurred'));
    };
    es.onmessage = e => {
      let progressState = {};
      try {
        progressState = JSON.parse(e.data)
      } catch(e) {}

      if(!verbose) {
        if(n === 8) n = 1;
        process.stdout.cursorTo(0);
        process.stdout.write(`${spin[n++]}`);
      }

      if(progressState && progressState.message) {
        es.close();
        return reject(new Error(`${progressState.deployProgress}: ${progressState.message}`))
      };

      if(progressState && progressState.deployProgress === 'registrated') {
        process.stdout.cursorTo(0);
        process.stdout.clearLine();
        process.stdout.write(chalk.gray(`Deployment ${progressState.deployProgress} [${(new Date().getTime() - startDate.getTime()) / 1000}s]`));
        process.stderr.write('\x1B[?25h'); //show terminal cursor
        es.close();
        settings.name = progressState.serviceName;
        settings.serviceUrl = progressState.serviceUrl;
        settings.alias = progressState.serviceAlias;
        settings.type = progressState.serviceType;
        settings.https = progressState.serviceHTTPS;
        settings.instances = progressState.serviceInstances;
        settings.aliveEndpoint = progressState.serviceAliveEndpoint;
        settings.variables = progressState.serviceVariables;
        copyPaste.copy(`https://${progressState.serviceAlias || progressState.serviceUrl || ''}`);
        return resolve(settings);
      }
      if(progressState && progressState.serviceName && verbose) {
        console.log(chalk.gray(`${progressState.serviceName} ${progressState.buildImageProgress || progressState.deployProgress || progressState.pushImageProgress} ${(progressState.log || '').replace('\n', '')}`))
      } else {
        if(progressState.deployProgress) {
          process.stdout.cursorTo(2);
          process.stdout.clearLine();
          process.stdout.write(chalk.gray(`${capitalizeFirstLetter(progressState.deployProgress)} [${(new Date().getTime() - startDate.getTime()) / 1000}s]`));
        }
      }
    };

    es.onopen = e => {
      fetch(`${settings.url}/deploys/${settings.name || ''}`, {
        method: 'POST',
        body: form,
        headers: { Authorization: `Bearer ${settings.token}`, }
      })
      .then(res => res.json())
      .then(data => {
        settings.name = data.serviceName;
        settings.serviceUrl = data.serviceUrl;
        settings.alias = data.serviceAlias;
        settings.type = data.serviceType;
        settings.https = data.serviceHTTPS;
        settings.instances = data.serviceInstances;
        settings.variables = data.serviceVariables;
        settings.aliveEndpoint = data.serviceAliveEndpoint;
      })
      .catch(err => {
        es.close();
        reject(err);
      });
    };

  });
}

function tarFileFilter(entry, excludes = []) {
  const exclude = !excludes.map(x => minimatch(entry.path, path.resolve(x)))[0];
  return exclude
  && entry.basename !== 'node_modules'
  && entry.basename !== 'npm-debug.log'
  && entry.basename !== '.git'
  && entry.basename !== '.DS_Store'
  && entry.basename !== '.dropstack.json';
}

function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}